## 3.1 Introduction
- Malware is persistent and employs various stealth techniques.
- Key locations to hunt for malware:
  - **Hiding in plain sight**: Common files and processes.
  - **Injected into processes**.
  - **Files**: Macros, executables.
  - **Email attachments**.
  - **Memory (Fileless malware)**.

---

## 3.2 Detection Tools

### **3.2.1 PE Capture**
- Captures PE files (executables, DLLs, drivers) loaded into the OS.
- Features:
  - GUI displays file path and hash.
  - Logs execution events.
  - Saves copies of loaded files in "Intercepted" folder.
- Variants:
  - GUI and service-only versions (service for multiple PCs).
- Free for personal use.
- Use case: Detect and analyze loaded executables or DLLs in memory.

---

### **3.2.2 ProcScan.rb**
- Scans process memory for code injection.
- Limitations:
  - Only supports **32-bit systems**.
- Usage:
  - Command: `ruby ProcScan.rb`
  - Output: Displays injected thread ID (e.g., `Thread ID 2516` in `rund1132` process).
  - Use PowerShell to correlate thread ID with the process:
    - `Get-Process` or alias `ps`.

---

### **3.2.3 Meterpreter Payload Detection**
- Scans running processes to detect active Meterpreter sessions.
- Usage:
  - Execute binary from an elevated command prompt.
- Features:
  - Continuous monitoring.
  - Outputs thread/process details if Meterpreter is detected.

---

### **3.2.4 Reflective Injection Detection**
- Detects reflective DLL injections in memory by identifying PE headers.
- Features:
  - Dumps related data (injected processes, unlinked executable pages) to the root folder.
  - Files are named by PID for correlation.
- Usage:
  - Run binary from elevated command prompt.
  - Use dumped files for further analysis.

---

### **3.2.5 PowerShell Arsenal**
- PowerShell module for reverse engineering and analysis:
  - Disassemble code, analyze memory, parse file formats.
  - Perform .NET malware analysis.
- Integration:
  - Run Reflective Injection Detection and capture output.
  - Use `Find-ProcessPEs` cmdlet to analyze the process further.
- Example:
  - Compare base addresses and gather detailed information about detected PEs.

---

### **3.2.6 Get-InjectedThread.ps1**
- PowerShell script to detect code injection:
  - Scans active threads and flags injected executable code.
- Usage:
  - Run script against a suspicious process (e.g., `rund1132` with PID 3624).
- Recommendation:
  - Conduct further independent research to fully understand the tool's output.

---

## Notes:
- Tools presented in this module represent an **introductory set**, not exhaustive.
- Practice proactive hunting using a combination of these tools.
- Remember: Correlation of outputs from different tools can enhance detection accuracy.

---

# 3.3 Detection Techniques

## Overview
- Malware authors often reuse or modify existing malware to avoid detection.
- Detection techniques can help identify:
  - Reused malware within a defined malware family.
  - Malware execution and correlate actions around execution time.

---

## Techniques Covered
1. **Fuzzy Hashing**
2. **Import Hashing**
3. **Execution Tracing**

---

### **3.3.1 Fuzzy Hashing**
- **Definition**: Fuzzy hashing identifies similar files even if they are not identical.  
  - It breaks files into smaller chunks and generates hashes for each chunk.
  - This allows detection of similarities even with changes such as insertions, deletions, or modifications in the file.
- **How It Works**:
  - Matches files with similar byte sequences, even if the content or length of bytes in between differs.
  - Ideal for detecting slightly modified or repackaged malware.
- **Tool**: **SSDeep**
  - A common fuzzy hashing tool used to compute **context triggered piecewise hashes (CTPH)**.
  - Often utilized by VirusTotal to analyze uploaded files and identify similar malware samples.
- **Example**:  
  Think of it as a way to find documents with similar phrases, even if the rest of the text is different.

---

### **3.3.2 Import Hashing (Imphash)**
- **Definition**: A hashing technique that tracks the functions or APIs called by an executable.  
  - Creates a hash (imphash) based on the order and names of imported libraries/functions.  
- **How It Works**:
  - Malware executables often reuse similar import tables. By hashing this information, related malware can be grouped or tracked.
  - Useful for identifying new malware variants created by the same threat actor.
- **Example**:
  - Imagine two malware samples using the same set of imported functions in a similar order. Import hashing can flag these as related.
- **Benefits**:
  - Quickly correlate malware samples.
  - Efficiently track malware families.

---

### **3.3.3 Execution Tracing**
- **Definition**: Tracks programs executed on a system to analyze their behavior and identify potential malware.  
  - Relies on execution trace artifacts like ShimCache or AmCache metadata.
- **How It Works**:
  - ShimCache (Application Compatibility Cache) records metadata of executed programs, originally for compatibility tracking.
  - Tools parse this data to reconstruct execution history and detect suspicious behavior.
- **Tools**:
  1. **ShimCacheParser**:
     - Extracts ShimCache metadata for analysis.
  2. **AppCompatProcessor**:
     - A more advanced tool with features like:
       - **Temporal Execution Correlation**: Matches events based on time.
       - **Time Stacking**: Analyzes event timelines for anomalies.
- **Example**:  
  These tools can reconstruct what programs were executed, helping detect malware activity even after the executable is removed.

---

## Summary
- **Fuzzy Hashing**: Identifies similar files by chunking and comparing hashes, even with modifications.  
- **Import Hashing**: Tracks malware samples based on the sequence of imported functions.  
- **Execution Tracing**: Analyzes execution history using system metadata to uncover suspicious behavior.  
- Combining these techniques enhances malware detection and investigation.

---

# 3.4 Memory Analysis

**Overview**  
Traditional file-system detection techniques are unreliable for detecting **memory-resident malware.** Memory analysis allows analysts to identify malware, extract valuable runtime information, and understand malware capabilities, bypassing rootkit interference.

---

## Key Advantages of Memory Analysis

- **Unprecedented visibility** into the run-time state of a system.
- Detect **running processes, open network connections, and executed commands** independently of the OS.
- Recover **critical data** like:
    - Encryption keys
    - Injected code fragments

---

## Memory Injection Techniques

Malware often manipulates or injects code directly into memory. Common techniques include:

- **Shellcode Injection**
- **DLL Injection** and **Reflective DLL Injection**
- **Process Hollowing**
- **API Hooking**
- **Gargoyle**

---

## Acquiring Memory

Before analyzing, **memory acquisition** (or dumping) is required. It involves mapping physical memory to a file (**memory image**).

#### **Approaches to Memory Acquisition**

1. **Hardware Acquisition**
    
    - Communicates directly with the memory controller (bypassing OS).
    - Resistant to rootkit interference.
    - Requires a PCI card for acquisition.
2. **Software Acquisition**
    
    - Maps the `\Device\PhysicalMemory` object.
    - Requires kernel-mode access.
    - **Requirements for stable tools**:
        - OS support
        - Minimal memory footprint
        - Ability to capture reserved memory sections
        - Output file support

**Drawbacks of Software Acquisition**:

- Consumes process/kernel memory, potentially overwriting evidence.
- Vulnerable to rootkit modifications.

#### **Tools for Memory Acquisition**

- **Non-Commercial Tools**:
    - FTK Imager
    - DumpIt
    - MAGNET RAM Capture

#### **Memory Acquisition in Virtual Machines**

- VM vendors provide memory files when systems are:
    - **Suspended**
    - **Snapshot Taken** (e.g., `.vmem` in VMware).
- Debugging mode may be required in **VirtualBox**.
- Memory dumps can also come from:
    - System crash files
    - Hibernation files

---

## Analyzing Memory: Identifying Anomalies

### **Process Anomalies**

- **Image Name**: Legitimate and correctly spelled?
- **Full Path**: Appropriate system path?
- **Parent Process**: Is it expected?
- **Command Line**: Do the arguments make sense?
- **Start Time**: Was the process active at boot?
- **Security Identifier (SID)**: Does a system process use a user SID?

### **Network Activity Anomalies**

- Processes communicating on ports **80, 443, 8080** (web ports) but not browsers.
- Browsers not using web ports.
- Connections to:
    - **Unexplained IP addresses** (internal or external).
    - Direct IP requests instead of domain names.
- **RDP Connections** (Port 3389): Suspicious IP origins.
- DNS requests for **unusual domain names**.

### **Additional Anomalies**

- **Unlinked Processes**
- **Suspicious DLLs**
- **Unlinked Network Connections**
- **Unmapped Memory Pages** with execute privileges (e.g., injected code).
- **Hooked API Functions**
- Detection via **YARA signatures** and bad heuristics.

---

## Tools for Memory Analysis

- **Mandiant's (FireEye) Redline**
- **Volatility**
- **Get-InjectedThreat.ps1**
- **Memdump**

---

## 3.4.1 Redline - Memory Analysis Tool

### **Overview**

**Redline** is FireEye’s free memory and file analysis tool that detects malicious activity on endpoints.

---

### **Key Features**

- **Live System Analysis**: Collects data on:
    - Running processes and drivers
    - File-system metadata
    - Registry data
    - Event logs and network info
    - Services, tasks, and web history
- **IOC (Indicator of Compromise) Analysis**:
    - Scans memory for pre-supplied IOCs.
    - Generates IOC hits for further analysis.
- **Portable Agent Creation**:
    - Collects live memory images from multiple systems.
- **MRI Score Index**:
    - Automates anomaly detection and assigns scores.
    - Provides a **high-level triage view** to spot rogue processes and rootkits.

---

### **Limitations**

- MRI Score Index may not always be accurate.
- It serves as a **triage tool**. For deeper investigations, use tools like **Volatility**.

---

### **Summary**

**Redline** provides a quick and automated overview of system memory for anomaly detection. Analysts use it for initial triaging before diving deeper with more advanced tools.

---

## **Key Takeaways**

- Memory analysis detects malware that avoids traditional file detection techniques.
- Hardware acquisition is resilient but requires specific equipment.
- Software acquisition is accessible but may overwrite evidence.
- Tools like **Redline** automate the detection process, while **Volatility** allows deeper analysis.
- Focus on process anomalies, network activity, and suspicious memory pages during analysis.

---

### **3.4.2 Memory Analysis - Volatility**

#### **Overview**

The Volatility Framework is an open-source tool for analyzing volatile memory (RAM). Written in Python, it offers powerful capabilities for extracting digital artifacts and understanding the runtime state of a system. It operates independently of the target system, ensuring detailed memory analysis.

---

#### **Key Features**

- Cross-platform support: Windows, Linux, Mac OS.
- Over 200 plugins available by default, with support for custom plugins.
- Requires three parameters for analysis:
    - **Memory dump file**
    - **Operating System (OS) profile**
    - **Plugin/Module** specifying the data to extract.

---

#### **OS Profile**

- Necessary because OS versions differ in memory object structures.
- Volatility includes profiles for Windows XP to Windows 10.
- If the OS profile is unknown, the `imageinfo` plugin can suggest likely profiles.

---

#### **Plugins for Process Analysis**

1. **pslist**:
    
    - Lists processes running on the system.
    - Includes terminated processes and their exit times.
    - Useful for detecting processes like `cmd.exe` launching malicious executables.
2. **psscan**:
    
    - Scans memory for process-like structures (`_EPROCESS`).
    - May detect terminated processes or false positives.
3. **psxview**:
    
    - Uses multiple techniques to locate processes.
    - Detects hidden processes, which may not appear in `pslist`.
4. **pstree**:
    
    - Shows processes in a hierarchical format.
    - Helps identify anomalies, such as unexpected parent processes.

---

#### **Network and Code Injection Detection**

- **netscan**:
    
    - Identifies active and inactive network connections in memory.
    - May show false positives or old connections.
- **malfind**:
    
    - Detects code injection by scanning memory regions.
    - Highlights processes with injected code, especially those with "MZ" headers (Windows executables).
    - Provides details like process name, PID, and disassembled code.
- **yarascan**:
    
    - Searches memory for specific patterns, strings, or YARA rules.
    - Useful for locating sophisticated malware.

---

#### **Code Injection Techniques**

- **DLL Injection**:
    
    - Inserts a DLL into a running process.
    - Requires administrative privileges or `SeDebugPrivilege`.
    - Steps:
        1. Attach to the victim process.
        2. Allocate memory in the process.
        3. Copy DLL or DLL path into memory.
        4. Execute the DLL.
    - Reflective DLL Injection executes directly from memory, avoiding disk detection.
- **Process Hollowing**:
    
    - Replaces a legitimate process’s memory with malicious code.
    - Often detected by scanning unmapped memory regions.
	
- **Code Example (Used for understanding only)**
	```C
	// 1. Get handle to target process
	handle = OpenProcess(target_process_id);

	// 2. Allocate memory in target process
	remote_memory = VirtualAllocEx(handle, size);
	
	// 3. Write DLL path to allocated memory
	WriteProcessMemory(handle, remote_memory, dll_path, path_length);
	
	// 4. Get address of LoadLibrary in target process
	load_library_address = GetProcAddress("kernel32.dll", "LoadLibraryA");
	
	// 5. Create remote thread to execute LoadLibrary with DLL path
	CreateRemoteThread(handle, load_library_address, remote_memory); 
	```

---

#### **Advanced Malware Detection**

- **Rootkit Detection**:
    
    - Useful plugins: `idt`, `ssdt`, `apihooks`, `modules`, `modscan`, `driverirp`, `driverscan`.
    - Helps investigate drivers, hooks, and system objects.
- **Malware Carving**:
    
    - Extract malicious objects (processes, drivers) from memory for further analysis.

---

#### **Takeaway**

Volatility is a robust framework for memory analysis, offering tools to identify processes, detect malware, and uncover hidden threats. Its plugins enable deep dives into memory artifacts, making it invaluable for digital forensics.

---

### **3.4.3 Live System Memory Hunting**

#### **Challenges of Memory Hunting**

- Performing memory dumps across all systems is impractical due to:
    - Time consumption.
    - Large memory sizes (e.g., 16GB on workstations, 64GB+ on servers).
- Hunting is typically limited to a subset of hosts.

---

#### **Tools for Live Memory Hunting**

These tools focus on detecting injected code directly on live systems, avoiding the need for memory dumps:

1. **Get-InjectedThread.ps1**
    
    - **Purpose**: Detects various injection techniques, including:
        - Classic Injection.
        - Reflective DLL Injection.
        - Memory Module Injection (similar to RDI).
    - **Features**:
        - Provides detailed information on processes and threads with injected code.
    - **Usage**:
        - A PowerShell script run on compromised hosts.
2. **Memhunter**
    
    - **Description**: A standalone binary that operates as a Windows service.
    - **Functionality**:
        - Feeds data to memory scanners using heuristics to detect potential attacks.
    - **Advantages**:
        - Scalable solution for memory inspection.
    - **Example**: A proof-of-concept video demonstrates its use.
3. **Captain**
    
    - **Purpose**: Endpoint monitoring tool designed to detect malicious events through API hooking.
    - It intercepts Windows API calls, allowing its DLL component to monitor and analyze process interactions with the OS, thus detecting code injection, memory dumps, fileless malware, and macro execution.
    - **Capabilities**:
        - Detects code injection, memory dump creation, fileless malware, and Office macro execution.
    - **Components**:
        1. **Monitor.ps1**: Monitors process creation and injects `Captain.dll`.
        2. **Injector.exe**: Handles injection of `Captain.dll`.
        3. **Captain.dll**: Hooks Windows API functions and logs events.
        4. **Behan.py**: Analyzes captured events using provided signatures.

---

### **3.5 Malware Analysis**

#### **Why Malware Analysis?**

- Helps understand the behavior and capabilities of malware.
- Useful for analyzing binaries in memory, especially for:
    - Packed or encrypted malware.
    - Extracting clear-text data from memory.

#### **Key Insights**

- Basic malware analysis skills are essential for a well-rounded threat hunter.
- Even without dedicated analysts, understanding malware aids in:
    - Inspecting network traffic.
    - Investigating malicious files across different systems.
    - Responding to incidents and conducting memory analysis.

---

### **Conclusion**

This module covered:

1. Tools and techniques for detecting malware.
2. Methods for memory analysis.
3. The role of malware analysis in threat hunting.

Equipped with these insights, threat hunters are better prepared to detect and respond to malicious activity.