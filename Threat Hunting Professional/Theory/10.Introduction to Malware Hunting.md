## 2.1 Introduction

During threat-hunting missions on endpoint systems, we hunt malware in various forms such as `.exe`, `.dll`, `.ps1`, etc.  
To successfully hunt malware, we need to understand:

- What malware is.
- How it infects endpoints.
- Techniques it uses to evade detection.

### What is Malware?

Malware is short for "malicious software."  
It is designed to infiltrate or damage systems without the owner's consent and can be:

- **Intrusive**
- **Hostile**
- **Annoying** (e.g., adware, PUPs – not our focus)

We will primarily focus on **intrusive and hostile malware** forms.

---

## 2.2 Malware Classifications

### **Viruses**

Viruses replicate and spread without the owner’s knowledge.  
They do not exploit vulnerabilities (those are worms) and rely on a host to spread.  
If an infected file is moved, the virus can spread.

#### Sub-types:

- **Resident**: Becomes memory-resident and infects other programs when triggered.
- **Non-Resident**: Searches for files to infect upon execution, then quits.
- **Boot Sector**: Spreads via boot sectors (e.g., infected USBs).
- **Multi-Partite**: Combines multiple infection methods (e.g., resident + boot sector).

---

### **Worms**

Spread via network/system vulnerabilities and often serve as entry points for other malware (e.g., rootkits).

---

### **Rootkits**

Designed to **hide compromises** or provide deeper system control.  
Typically installed as drivers or kernel modules, rootkits can:

- Hide processes.
- Add files to the file system.
- Implement backdoors.
- Create security loopholes.

#### Levels:

1. **Application Level**: Replaces or manipulates application binaries.
2. **Library Level**: Compromises shared libraries to control multiple apps.
3. **Kernel Level**: Operates at the same privilege as antivirus, making it difficult to remove.
4. **Hypervisor Level**: Uses virtualization features (e.g., Blue Pill, SubVirt).
5. **Firmware Level**: Targets BIOS, device ROMs, or ACPI tables, making detection extremely difficult.

---

### **Bootkits**

- Attack before the OS starts.
- Fully compromise system security.

---

### **Trojans**

Appear legitimate but perform malicious activities, e.g., bundling malware with a game.

---

### **Backdoors**

Bypass authentication and provide unauthorized access.  
Examples include **Remote Access Trojans (RATs)**, which use client-server models for remote control.

---

### **Spyware**

Collects user data (e.g., visited websites) and often works alongside other malware (e.g., rootkits, trojans).

---

### **Botnets**

A network of compromised systems (bots) controlled by a **bot master**.  
Used for:

- DDoS attacks.
- Spam campaigns.

---

### **Ransomware**

Encrypts files and demands payment (usually in Bitcoin) for decryption keys.  
Also called **extortive malware**.

---

### **Information Stealers**

Focus on stealing sensitive data such as:

- Private keys.
- Login credentials.
- Credit card data.

#### Examples:

1. **Keyloggers**: Capture keystrokes.
2. **Screen Recorders**: Take screenshots based on conditions (e.g., time intervals).
3. **RAM Scrapers**: Steal unencrypted data directly from memory.

---

### Note on Overlaps

Malware types often overlap (e.g., a trojan with a backdoor).  
Understanding classifications helps identify their purpose and possible actions.

---

## **Malware Delivery Methods**

|**Delivery Method**|**Description**|**Examples/Tools**|
|---|---|---|
|**Physical Media**|Malware delivered via physical devices like USB drives, often configured to autorun or infect boot sectors.|USB Rubber Ducky, BadUSB, Teensy|
|**Email (Attachments)**|Crafted emails with malicious attachments (phishing, spear phishing).|PDFs, Word documents with macros|
|**URL Links**|Links redirecting victims to malware-hosting websites or directly downloading malware.|Shortened URLs (bit.ly), phishing sites|
|**Drive-by Downloads**|Malware installs automatically when a victim visits a compromised site, leveraging unpatched software.|Exploit kits, SEO attacks, watering holes|
|**Web Advertising**|Malvertising delivers malware through online ads, sometimes without interaction.|Browser extension abuse, injected scripts|
|**Social Media**|Platforms exploited to spread malicious links via posts or direct messages.|Fake promotions, malicious campaigns|
|**File Shares**|Malware propagates via shared drives or cloud storage platforms.|Infected shared files|
|**Software Vulnerabilities**|Exploits vulnerabilities in applications (e.g., buffer overflows) to execute malicious code.|Stack/Heap overflows|

---

# Malware Evasion Techniques

---

#### **Alternate Data Streams (ADS)**

- **Description**: Hidden data stored in NTFS streams, separate from the main file.
- **Key Tools/Commands**: `echo`, `DIR`, `Get-Item`, Sysinternals `streams.exe`
- **Purpose**: Conceal malicious data within NTFS streams.
- **Steps**:
    1. Create a file with `echo`.
    2. Append ADS to the file using `echo`.
    3. View ADS using `Get-Item` or `streams.exe`.

---

#### **DLL Injection**

- **Description**: Injecting a malicious DLL into a legitimate process.
- **Key APIs**: `CreateToolhelp32Snapshot`, `VirtualAllocEx`, `WriteProcessMemory`, `CreateRemoteThread`
- **Purpose**: Execute malicious DLL in a target process.
- **Steps**:
    1. Locate target process (`CreateToolhelp32Snapshot`).
    2. Open the process (`OpenProcess`).
    3. Allocate memory (`VirtualAllocEx`).
    4. Copy DLL path into memory (`WriteProcessMemory`).
    5. Execute with `CreateRemoteThread`.

---

#### **Reflective DLL Injection**

- **Description**: Loading a DLL directly into memory without touching disk.
- **Tools**: Custom code, Metasploit, PowerShell Empire
- **Purpose**: Avoid detection by not writing to disk.
- **Steps**:
    1. Inject DLL into memory.
    2. Resolve import addresses.
    3. Load DLL without `LoadLibrary`.

---

#### **Thread Hijacking**

- **Description**: Malware injects code into an existing thread of a running process instead of creating a new one.
- **Purpose**: Execute malicious code within the context of a legitimate process, without the need for creating new threads.

**Steps**:
	1. **Locate Thread**: Identify a target thread in the process.
	    - **API**: `CreateToolhelp32Snapshot()`, `Thread32First()`
	2. **Open Thread**: Open the thread for manipulation.
	    - **API**: `OpenThread()`
	3. **Suspend Thread**: Pause the thread to prepare for injection.
	    - **API**: `SuspendThread()`
	4. **Allocate Memory**: Reserve memory for malicious code.
	    - **API**: `VirtualAllocEx()`
	5. **Copy**: Write the malicious code into the allocated memory.
	    - **API**: `WriteProcessMemory()`
	6. **Resume Thread**: Restart the thread to execute the code.
	    - **API**: `ResumeThread()`

---

#### **Process Hollowing**

- **Description**: Replaces a process's memory with malicious code.
- **Key APIs**: `CreateProcess`, `ZwUnmapViewOfSection`, `VirtualAllocEx`, `WriteProcessMemory`, `SetThreadContext`
- **Purpose**: Disguise malicious code as a legitimate process.
- **Steps**:
    1. Create a suspended process (`CreateProcess`).
    2. Un-map legitimate code (`ZwUnmapViewOfSection`).
    3. Allocate memory for malicious code (`VirtualAllocEx`).
    4. Write code (`WriteProcessMemory`).
    5. Set entry point (`SetThreadContext`).
    6. Resume process (`ResumeThread`).

---

#### **Portable Executable (PE) Injection**

- **Description**: Injecting a Portable Executable (PE) file into another process.
- **Key APIs**: `VirtualAllocEx`, `WriteProcessMemory`
- **Purpose**: Inject malicious PE into a process without writing to disk.
- **Steps**:
    1. Locate target process.
    2. Allocate memory (`VirtualAllocEx`).
    3. Write malicious PE to allocated memory.
    4. Adjust base address and relocate.
    5. Execute injected PE.

---

#### **Hooking**

- **Description**: Intercepts events to execute malicious actions.
- **Key APIs**: `SetWindowsHookEx`, SSDT, IAT/EAT Hooking
- **Purpose**: Modify or monitor system behavior.
- **Steps**:
    1. Set a hook (`SetWindowsHookEx`).
    2. Modify SSDT or IAT to redirect functions.
    3. Trigger malicious function.

---

#### **SSDT Hooking**

- **Description**: Modifying entries in the System Service Descriptor Table to redirect system calls.
- **Key APIs**: SSDT manipulation
- **Purpose**: Alter kernel-level function calls for hiding files or processes.
- **Steps**:
    1. Hook SSDT entry (e.g., `NTQueryDirectoryFile`).
    2. Call malicious function.
    3. Modify results and pass back.

---

#### **I/O Request Packets (IRP) Hooking**

- **Description**: Intercepts I/O request packets (IRPs) to modify or hide malicious activity at the kernel level.
- **Key APIs**: `DriverObject->MajorFunction[IRP_POWER]`, `IoCallDriver`
- **Purpose**: Hide or alter I/O operations, such as files or registry accesses, to evade detection.
- **Steps**:
    1. Hook kernel function pointers that process IRPs (`DriverObject->MajorFunction`).
    2. Redirect or modify the IRP to execute malicious code or hide data.
    3. Process or forward the IRP with altered data (e.g., hide malicious processes, files).

---
#### **Import Address Table (IAT) Hooking**

- **Description**: Modifies the Import Address Table (IAT) to redirect function calls made by an executable to malicious code.
- **Key Concepts**: IAT resolves runtime dependencies by listing API functions needed by a program.
- **Purpose**: Intercept and modify system function calls at runtime, often used for malware to hijack API calls in both DLLs and EXEs.
- **Steps**:
    1. Identify the target function in the IAT.
    2. Modify the IAT entry to point to malicious code.
    3. Trigger the malicious code when the function is called.

---

#### **Export Address Table (EAT) Hooking**

- **Description**: Modifies the Export Address Table (EAT) in DLLs to redirect calls from other executables to malicious code.
- **Key Concepts**: EAT exists in DLLs and contains functions for use by other executables.
- **Purpose**: Hijack exported functions in DLLs to control behavior when other programs interact with the DLL.
- **Steps**:
    1. Identify the target function in the EAT of the DLL.
    2. Modify the EAT entry to point to malicious code.
    3. Redirect function calls to the malicious code when they are made by other processes.

---
#### **Inline Hooking**

- **Description**: Modifying function code directly to redirect execution.
- **Purpose**: Redirect API execution to malicious code.
- **Steps**:
    1. Modify function's first few bytes.
    2. Redirect execution flow to malicious code.

---

#### **Rootkits: Process Hiding**

- **Description**: Rootkits hide their existence by making their processes invisible to conventional detection methods.
- **Key Techniques**:
    - **NtOpenProcess Hooking**: Hooks the Native API function to prevent process enumeration.
    - **Unlinking from EPROCESS List**: Removes the process from the system's active process list.
    - **Unlinking from PsLoadedModuleList**: Hides the driver by unlinking it from the loaded modules list.
- **Steps**:
    1. Hook `NtOpenProcess` to prevent process enumeration.
    2. Modify the `ActiveProcessLinks` structure to unlink the malicious process.
    3. Unlink the driver from the `PsLoadedModuleList` to prevent detection.

#### Train Analogy
- **DLL Injection:** Adding a new cart (DLL) to the train (process) using the standard coupling procedure (`LoadLibrary`).
- **Reflective DLL Injection:** Smuggling a custom-built cart (DLL) onto the train and discreetly connecting it from within, bypassing the standard procedure.
- **Thread Hijacking:** Instead of adding a new cart, the attacker grabs control of the train's engine room (a thread) and forces the engineer to follow their commands.
- **PE Injection:** Similar to process hollowing, but instead of replacing the entire cargo, the attacker injects a malicious package into one of the existing cargo containers.
- **Process Hollowing:** Unloads the original cargo of the train and replaces it entirely with malicious cargo, making it look like a legitimate train while carrying a different load.
- **Hooking:** Places a switch on the tracks that can divert the train (execution flow) temporarily to a side track (the hook) before returning it to the main line.
- **SSDT Hooking:** Tampers with the central train schedule (System Service Dispatch Table) so that certain destinations (system calls) are rerouted to malicious locations.
- **IRP Hooking:** Intercepts messages sent between the train cars (I/O Request Packets) to eavesdrop, modify, or block communication.
- **IAT Hooking:** Modifies the train's cargo manifest (Import Address Table) to redirect deliveries (function calls) to a different location controlled by the attacker.
- **EAT Hooking:** Modifies the train company's public service directory (Export Address Table) to advertise malicious services under the guise of legitimate ones.
- **Inline Hooking:** Replaces a section of the existing track (code) with a malicious section, seamlessly integrating the malicious code into the train's path.
- **Rootkits (Process Hiding):** Uses cloaking technology to make the train invisible to the control tower (process monitoring tools), effectively hiding its existence and malicious activity. This might involve manipulating the train's identification transponder or jamming communication signals.

---
## **Masquerading**

- **Description**: Malware attempts to appear as legitimate software or processes to avoid detection by mimicking familiar system files or behaviors.
    
- **Techniques**:
    
    - **Name Masquerading**:
        - Naming malware files similar to well-known system files (e.g., `svch0st.exe`, `scvhost.exe`, `svchost32.exe`) to confuse both users and security tools.
        - A wide variety of name variations can be used to mimic `svchost.exe` and other critical system files.
    - **Location Masquerading**:
        - Malware is placed in system directories like `C:\Windows`, `C:\Windows\System32`, or other trusted locations, making it harder to distinguish from legitimate files.
    - **Other Hiding Locations**:
        - Temporary folders, Program Files, Recycle Bin, or hidden directories are often used to hide malware.
        - The malware may choose folders where the user or security software is unlikely to suspect an infection.

---

#### **Packers**

- **Description**: Software that compresses or encrypts malware executables to evade detection by obfuscating the file's content.
    
- **Purpose**:
    
    - **Compression**: By compressing the executable, packers reduce the file's size, which hides patterns that could be detected by antivirus (AV) software.
    - **Encryption**: Some packers also encrypt the code, making it more challenging for AV programs to analyze the file's actual behavior.
- **Common Packers**:
    
    - **Custom Packers**: Malware authors may develop custom packers (e.g., Yoda Packer) to further evade detection by AV solutions.
    - **Standard Packers**: Common, readily available packers like UPX are frequently used.
- **Steps**:
    
    1. The malware file is compressed or encrypted using a packing tool.
    2. The signature (e.g., MD5 hash) of the packed file changes, which makes it appear as a new, unique file.
    3. When executed, the packed malware decompresses or decrypts itself in memory to execute its payload.

---

#### **Code Obfuscation**

- **Description**: Malware authors modify the program code to make it difficult for analysts and automated tools to understand or reverse-engineer.
    
- **Purpose**:
    
    - **Avoid Detection**: Obfuscation prevents detection by signature-based security tools.
    - **Difficulty in Analysis**: It also makes reverse engineering or debugging significantly harder, protecting the malware’s functionality and behavior.
- **Methods**:
    
    - **Self-modifying Code**: Malware may alter its own code during execution to evade static analysis tools that inspect code before it runs.
    - **Encryption and Decryption**: The malware may encrypt parts of its code and decrypt them only at runtime.
    - **Code Rewriting**: The malware may use different code variants, each time infecting a new system, to avoid recognition by traditional signature-based detection systems.
- **Common Anti-Reversing Techniques**:
    
    - **Virtual Machine Detection**: Malware may check if it's running in a virtual machine (VM) as a sign of analysis or sandboxing environments, and behave differently.
    - **Debugger Detection**: Malware may check for debuggers or emulators, and alter its behavior or avoid execution if one is detected.
    - **Junk Code Insertion**: Random or fake code is inserted to mislead reverse engineering efforts or delay analysis.

---
## **Malware Persistence**

- **Description**: Malware uses persistence mechanisms to ensure it continues to run even after a system reboot, often leveraging system tools and registry entries.

---

### **Autostart Locations**

- **Registry Locations**:
    
    - Common:
        - `HKLM\Software\Microsoft\Windows\CurrentVersion\Run`
        - `HKCU\Software\Microsoft\Windows\CurrentVersion\Run`
    - Additional Common:
        - `HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run`
        - `HKCU\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run`
    - Less Common:
        - `HKLM\Software\Microsoft\Windows NT\CurrentVersion\WinLogon\Userinit`
        - `HKLM\Software\Microsoft\Windows NT\CurrentVersion\Image File Execution Options`
        - `HKLM\Software\Wow6432Node\Windows NT\CurrentVersion\Image File Execution Options`
- **Tools**: Tools like Sysinternals' **AutoRuns** provide a comprehensive list of locations used by malware for persistence.

---

### **Scheduled Tasks**

- **Description**: Utilities like `at.exe` and `schtasks.exe` allow malware to schedule tasks based on time or events.
- **Example**:
    - **APT3**:
        - `schtasks [create /tn "mysc" /tr C:\Users\Public\test.exe /sc ONLOGON /ru "System"]`

---

### **COM Hijacking**

- **Description**: COM (Component Object Model) allows different software components to interact. Malware can hijack COM references to execute malicious code instead of legitimate processes.
- **Purpose**: Allows malware to execute without raising suspicion by leveraging legitimate COM infrastructure.

---

### **DLL Hijacking**

- **Description**: Malware exploits the DLL search order to inject malicious code. When an executable runs, it searches for required DLLs. The search often starts in the local directory before checking `C:\Windows\System32`.
- **Techniques**:
    - Place malicious DLLs in the path of missing or outdated DLLs that the executable is attempting to load.
    - **Resources**: Hexacorn's blog provides in-depth information on Phantom DLLs.

---

### **DLL Hijacking: Phantom DLL**

- **Description**: This technique targets executables attempting to load old or missing DLLs no longer present in modern Windows operating systems.
- **Techniques**:
    - Attackers place a malicious DLL with the same name as the missing one to ensure it gets loaded by the executable.

---
### **WinSxS Folder Hijacking**

- **Description**: The WinSxS folder is used for managing different versions of DLLs in Windows. Malware can place a malicious DLL in this folder, which may be loaded instead of a legitimate one.
- **Techniques**:
    - Exploiting the WinSxS folder prevents versioning issues and can be used for persistence.

---

### **Service Creation**

- **Description**: Malware can create a malicious service that runs at system boot. These services can hide among legitimate system services.
- **Tool**: The `sc` command is used to create services that load before antivirus software, often granting persistence and elevated privileges.

---

### **Service Replacement**

- **Description**: Malware may replace a legitimate service with malicious code. This is often done when services have poor Access Control List (ACL) configurations.
- **Privileges**: Low-privileged accounts can exploit this technique, replacing executables with malware.

---

### **Service Recovery Actions**

- **Description**: Malicious services can be configured to trigger recovery actions (e.g., executing malware) if they fail, ensuring the malware restarts automatically after a failure.

---

### **Conclusion**

This section covered:

- Various methods malware uses to maintain persistence.
- The use of autostart locations, scheduled tasks, COM hijacking, DLL injection, and service manipulation.
- Resources for further research, including AutoRuns, ATT&CK, and Hexacorn's blog.

---
